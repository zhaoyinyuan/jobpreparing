[TOC]

## 2019.6.10

#### Linux下通过哪个命令怎么查看中断？B

```
cat /proc/ioports
cat /proc/interrupts
cat /proc/kcore
cat /proc/kms
```

/proc/interrupts 显示使用的中断

/proc/ioports 当前使用的I/O端口

/proc/kcore 系统物理内存映像。与物理内存大小完全一样，但不实际占用这么多的内存。

/proc/kmsg  内核输出的消息，也被送到syslog

**中断**是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。Linux中通常分为外部中断（又叫硬件中断）和内部中断（又叫异常）。

#### Linux文件权限一共10位长度，从前数第5-7位表示的内容是（A）
```
文件所有者所在组的权限
文件类型
文件所有者的权限
其他用户的权限
```

​        d                         rwx                                  rwx                                            rwx

​        ↑                           ↑                                       ↑                                                 ↑

是否为文件夹    所有者的权限          文件所有者组的权限                     其他用户的权限

#### Linux系统中某个可执行文件属于root并且有setid，当一个普通用户 mike运行这个程序时，产生的进程的有效用户和实际用户分别是？A

```
root mike
root root
mike root
mike mike
deamon mike
mike deamon
```

setuid位是让普通用户可以以root用户的角色运行只有root帐号才能运行的程序或命令。
因此当程序设置了setid权限位时，普通用户会临时变成root权限，但实际用户任然是原来的mike

#### Linux系统中，用户文件描述符0表示 _A 。

```
标准输入设备文件描述符
标准输出设备文件描述符
管道文件描述符
标准错误输出设备文件描述符
```

在Linux系统中,一切设备都看作文件。而每打开一个文件,就有一个代表该打开文件的文件描述符。程序启动时默认打开三个I/O设备文件:标准输入文件stdin,标准输出文件stdout,标准错误输出文件stderr,分别得到文件描述符0,1,2。

文件描述符0：标准输入文件stdin

文件描述符1：标准输出文件stdout

文件描述符2：标准错误输出文件stderr

#### 下面关于Android dvm的进程和Linux的进程,应用程序的进程说法正确的是 D

```
DVM指dalvik的虚拟机.每一个Android应用程序都在它自己的进程中运行，不一定拥有一个独立的Dalvik虚拟机实例.而每一个DVM都是在Linux中的一个进程，所以说可以认为是同一个概念.
DVM指dalvik的虚拟机.每一个Android应用程序都在它自己的进程中运行，不一定拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux 中的一个进程，所以说不是一个概念.
DVM指dalvik的虚拟机.每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux 中的一个进程，所以说不是一个概念
DVM指dalvik的虚拟机.每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的 Dalvik虚拟机实例.而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念.
```

一句话：每一个DVM都是在Linux 中的一个进程！

DVM指 dalivk 的虚拟机。每一个 Android 应用程序都在它自己的进程中运行，都拥有一个独立的 Dalvik 虚拟机实例。而每一个 DVM 都是在 Linux  中的一个进程，所以说可以认为是同一个概念。 

#### 在重新启动Linux系统的同时把内存中的信息写入硬盘，应使用（A）命令实现

```
#shutdown -r now
#halt
#reboot
#init3
```

在linux命令中reboot是重新启动，**shutdown -r now是立即停止然后重新启动，都说他们两个是一样的，其实是有一定的区别的**。

**shutdown**命令可以**安全地关闭**或重启Linux系统，它在系统关闭之前给系统上的所有登录用户提示一条警告信息。该命令还允许用户指定一个时间参数，可以是一个精确的时间，也可以是从现在开始的一个时间段。

精确时间的格式是hh:mm，表示小时和分钟，时间段由+ 和分钟数表示。系统执行该命令后会自动进行数据同步的工作。

该命令的一般格式: shutdown [选项] [时间] [警告信息]

命令中各选项的含义为:

\- k 并不真正关机而只是发出警告信息给所有用户

\- r 关机后立即重新启动

\- h 关机后不重新启动

\- f 快速关机重启动时跳过fsck

\- n 快速关机不经过init 程序

\- c 取消一个已经运行的shutdown  

**halt**是最简单的关机命令，其**实际上是调用shutdown -h命令**。

**reboot**的工作过程与halt类似，其作用是重新启动，而halt是关机。其参数也与halt类似。reboot命令重启动系统时是删除所有的进程，而不是平稳地终止它们。因此，**使用reboot命令可以快速地关闭系统，但如果还有其它用户在该系统上工作时，就会引起数据的丢失。所以使用reboot命令的场合主要是在单用户模式**。

**init**是所有进程的祖先，其进程号始终为1。init用于切换系统的运行级别，切换的工作是立即完成的。**init 0命令用于立即将系统运行级别切换为0，即关机；init 6命令用于将系统运行级别切换为6，即重新启动**

####  init启动进程需要读取()配置文件 D

```
/sbin/init
/bin/sh
/etc/sysvinit
/etc/inittab
```

/sbin/init在核心完整的加载后，开始运行系统的第一支程序，主要的功能就是准备软件运行的环境，包括系统的主机名称、网络配置、语系处理、文件系统格式及其他服务的启动等。 

/bin/sh解释脚本的shell命令，开机后运行

/etc/sysvinit就是 system V 风格的 init 系统，顾名思义，它源于 System V 系列 UNIX。sysvinit 中运行模式描述了系统各种预订的运行模式。(初始化用)

/etc/inittab定义了系统引导时的运行级别, 进入或者切换到一个运行级别时做什么。

####  一个文件名字为rr.Z，可以用来解压缩的命令是：D

```
tar
gzip
compress
uncompress
```

tar是操作.tar的命令
gzip是压缩.gz压缩包的命令
compress：压缩.Z文件
uncompress：解压缩.Z文件

#### 目录在linux文件系统中是以怎样的形式存在的？B

```
文件夹
文件
inode
软链接
```

一切皆文件

####  有一个文件ip.txt，每行一条ip记录，共若干行，下面哪个命令可以实现“统计出现次数最多的前3个ip及其次数”？（B）
```
uniq -c ip.txt│sort -nr│head -n 3
sort ip.txt│uniq -c│sort -rn│head -n 3
cat ip.txt │count -n│sort -rn│head -n 3
cat ip.txt │sort │uniq -c│sort -rn│top -n 3
```

sort 是按ASCII码排序

-n   依照数值的大小排序。

-r   以相反的顺序来排序。

uniq -c 是去重并显示个数

head -n 3 为取前3行

####  Linux中，一个端口能够接受tcp链接数量的理论上限是？D

```
1024
65535
65535 * 65535
无上限
```

标识一个TCP连接的是，客户端和服务器的IP地址加端口号，尽管服务器IP地址和端口号一样，但是客户端IP地址是不一样的，而客户端端口号只有本地意义，所以理论上服务器一个端口号能接受的TCP连接是无上限的。

####  UNIX系统中进程由三部分组成：进程控制块，正文段和数据段。这意味着一个程序的正文与数据可以是分开的，这种分开的目的是为了？A B C

```
可共享正文
可共享数据
可重入
方便编程
以上全部
```

通常，一个进程由三个部分组成：进程控制块PCB、数据和程序。在UNIX中，一个进程也由三个部分组成：进程控制块、数据段和共享正文段，并有其自身的不同含义。
进程运行时用到的数据以及工作区，构成了一个进程的数据段。要注意的是，如果进程执行的程序是不能被共享的，那么也把它归入到数据段中。
为了管理好进程的共享正文段，UNIX在内存专门开辟了一个text结构区域，形成正文段表text[ ].
因此，划分进程为进程控制块、正文段、数据段可以实现共享正文，共享数据和可重入。

#### Redhat 9所支持的安装方式有?A C D 

```
通过HTTP进行网络安装
通过Telnet进行网络安装
通过NFS进行网络安装
从本地硬盘驱动器进行安装
```

光盘安装 (常规情况) 硬盘安装 (无光驱情况)
网络安装-NFS方式 (适合于批量安装大量服务器，和kickstart自动安装一起使用)
网络安装-FTP方式 (适合于批量安装大量服务器，和kickstart自动安装一起使
网络安装-HTTP方式 (适合于批量安装大量服务器，和kickstart自动安装一起使

#### 关于静态库与动态库的区别，以下说法错误的是（A）

```
加载动态库的程序运行速度相对较快
静态库会被添加为程序的一部分进行使用
动态库可用节省内存和磁盘空间
静态库重新编译，需要将应用程序重新编译
```

**1静态链接库的优点** 

 (1)代码装载速度快，执行速度略比动态链接库快； 

 (2)只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 

**2动态链接库的优点** 

 (1)更加节省内存并减少页面交换；

 (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；

 (3)不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；

 (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。

**3不足之处**

 (1)使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；

 (2)使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。

**动态库的函数到实际使用的时候才加载到内存，所以运行速度较慢**

#### linux下查看当前网络连接的命令。B

```
ping
netstat
route
tracert
```

ping 命令不用说大家都知道，不论windows还是linux，对于PING命令无非是在测试网络连接的性能情况
netstat，字面理解网络状态，包括网络地址信息，网络的连接状态，网络的子网掩码等等，通过命令 netstat -ie ，效果和ifconfig一样
route是路由表信息命令主要是查看路由表相关的
tracert表示并不是很准确，在linux下应该是traceroute，字面理解路径追踪，其实就是在网络中包通过的路由器等相关的个数信息。

#### 使用pthread库的多线程程序编译时需要加什么连接参数? A

```bash
-lpthread
-fthis-is-varialble
-fcond-mismatch
-MMD
```

  由于pthread库不是[Linux](http://lib.csdn.net/base/linux)系统默认的库，连接时需要使用库libpthread.a,所以在使用pthread_create创建线程时，在编译中要加-lpthread参数:
gcc -o pthread -lpthread pthread.c

-fthis-is-varialble 就是向传统c++看齐，可以使用this当一般变量使用.

-fcond-mismatch允许 [条件表达式](http://baike.baidu.com/view/3523810.htm) 的第二和第三参数 [类型不匹配](http://baike.baidu.com/view/672303.htm) ，表达式的值将为void类型

-MMD和-MM相同，但是输出将导入到.d的文件里面

#### 写出完成以下功能的Linux命令:使用sed命令, 将文件xyz中的单词AAA全部替换为BBB (B)

```
sed 's/AAA/BBB' xyz
sed 's/AAA/BBB/g' xyz
sed 's/AAA/BBB/p' xyz
sed 's/AAA/BBB/d' xyz
```

s表示替换命令， /AAA 表示匹配AAA， /BBB 表示把匹配替换成BBB，/g 表示一行上的替换所有的匹配） xyz 表示替换xyz文件中的xyz

 g 表示行内全面替换。 

p 表示打印行。 

w 表示把行写入一个文件。

x 表示互换模板块中的文本和缓冲区中的文本。

y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）

\1 子串匹配标记 

& 已匹配字符串标记   

#### 采用多路复用I/O监听3个套接字的数据时，如果套接字描述符分别是：5,17,19,则

```bash
`select(``int` `maxfd,``struct` `fd_set* rdset,NULL,NULL)`
```

中的maxfd应取为（B)

```
4
20
5
9
```

Maxfd要监视的文件描述符的范围，一般取监视的描述符数的最大值+1

#### 在unix系统下执行chmod(“/usr/test/sample”,0753)之后该文件sample的访问权限为 C

```
拥有者可读写执行，同组用户可写可执行，其他用户可读可执行
拥有者可读写执行，同组用户可读写，其他用户可读可执行
拥有者可读写执行，同组用户可读可执行，其他用户可写可执行
拥有者可读写执行，同组用户可读可执行，其他用户可读写
```

r：读取权限，数字代号为"4"。 

w：写入权限，数字代号为"2"。 

x：执行或切换权限，数字代号为"1"。 

7：421  5:41 3:12 分别为三种不同用户对文件所执行的操作，7代表对文件拥有者所能执行的操作，为4+2+1的组合， 代表可读客写可执行；5代表同组用户客执行的操作，只能为4+1的组合，代表可读可执行；3为其他用户所能执行的操作，为2+1的组合，代表可写可执行。

#### 下面说法哪个正确的：D

```
各个线程拥有相同的堆栈
i++是线程安全的，不需要同步
x=y是线程安全的，不需要同步
对进程来说，其虚拟内存的大小不受物理内存大小的限制
```

**D。**进程的虚拟内存大小并不受物理内存大小的限制，例32位处理器虚拟内存空间可能是4G，但物理内存实际是小于4G的，部分地址空间分配给了ROM、外设等。

A，各个线程有自己的堆和栈，并不相同。

B，i++操作不一定是原子性操作，CPU在执行时可能需要几条指令才能完成，包括读内存内容到寄存器，操作寄存器，从寄存器写回内存。

C，同B。

#### 关于 Linux 系统上同一个程序的多个进程实例共享一个 TCP 监听端口的说法, 哪个不正确?D

```
每个进程都使用 SO_REUSEPORT 选项,然后绑定同一个地址和端口
每个进程分别绑定不同的网卡地址的同一端口
第一个进程先绑定到监听地址端口, 然后 fork 子进程共享使用
每个进程分别绑定一次, 但只有最后一个调用的进程才能收到数据
```

D是竞争调度的结果，而不是最后调用的进程收到数据。

A使用SO_REUSEPORT，绑定统一地址和端口。

B分别绑定 不同的网卡地址的同一端口，TCP的四元组并不冲突。

C使用fork创建子进程共享，也没有问题。

#### 下面关于i节点描述错误的是A

```
i节点和文件是一一对应的
i节点能描述文件占用的块数
i节点描述了文件大小和指向数据块的指针
通过i节点实现文件的逻辑结构和物理结构的转换
```

在做这道题之前首先要明白i节点是什么东西！

linux中，文件查找不是通过文件名称来查找的。实际上是通过i节点来实现文件的查找定位的。我们可以形象的将i节点看做是一个指针fip.

这个节点和文件不是一一对应的，通过ln可以建立其他的节点。

节点与文件是一对多。在硬链接下，多个文件名共用一个iNode

#### 在CPU和物理内存之间进行地址转换时，（B ）将地址从虚拟（逻辑）地址空间映射到物理地址空间

```
TCB
MMU
CACHE
DMA
```

A.TCB,线程控制块；PCB，进程控制块

B.MMU(Memory Management Unit) 内存管理单元，是中央处理器用来管理虚拟内存和物理内存寄存器的控制线路，同时也负责虚拟内存映射为物理内存等。

C.CACHE,感觉在这道题里应该指的是高速缓冲存储器。

D.DMA，（direct memory access）直接内存存储，传输数据从一个地址空间到另一个地址空间。

#### 在RHEL5系统中，下面关于shell环境变量配置文件的描述，正确的是（ A ）

```
用户登录系统时，bash首先执行/etc/profile配置文件和/etc/profile.d/目录下的配置文件，这些配置文件对所有用户都有效
用户登录系统时，bash首先执行.bash_profile文件和.bashrc文件，这些配置文件对所有用户都有效
用户主目录下的.bashrc设置为每次登录时执行，而.bash_profile则为每次打开新的终端时执行
执行用户主目录下的环境变量配置文件时，不可以重复设置用户登录时配置文件中已经设置的选项
```

- /ect/profile
  - 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从 **/etc/profile.d** 目录的配置文件中搜集shell的设置.
- /etc/bashrc
  - 为每一个 **运行bash shell** 的用户执行此文件.当bash shell被打开时,该文件被读取.
- ~/.bash_profile
  - 每个用户都可使用该文件输入 **专用于** 自己使用的shell信息, **当用户登录时,该文件仅仅执行一次** !默认情况下,他设置一些环境变量,执行~/.bashrc文件.
- ~/.bashrc
  - 该文件包含专用于用户的bash shell的bash信息 **,当登录时以及每次打开新的shell时,该该文件被读取** .
- ~/.bash_logout
  - 当每次退出系统(退出bash shell)时,执行该文件.

#### 程序员小李通过管道统计prog.c函数中for语句通过的次数，需要使用的指令分别是BC

```
vi
grep
wc
sort
```

#### 将光盘/dev/hdc卸载的命令是?AC

```
umount /mnt/cdrom /dev/hdc
mount /dev/hdc
umount /dev/hdc
mount /mnt/cdrom /dev/hdc
```

挂载设备使用mount，卸载设备使用umount，有三种方式，通过设备名，挂载点或者设备名和挂载点

如题目所示：

umount /dev/hdc

umount /mnt/cdrom

umount /mnt/cdrom /dev/hdc

## 2019.6.25

#### 在局域网络内的某台主机用ping命令测试网络连接时发现网络内部的主机都可以连同，而不能与公网连通，问题可能是C

```
主机IP设置有误
没有设置连接局域网的网关
局域网的网关或主机的网关设置有误
局域网DNS服务器设置有误
```

A 主机IP地址有误  不对，若是主机IP地址有误的话内网也不会通的
B 没有设置连接局域网的网关，也不对，因为若是没有连接局域网网关，局域网内也不会通，不可能所有主机都是两两连接吧
C局域网的网关或主机的网关设置有误，   局域网的网关设置有误，是可以的，主机的网关设置有误，那么内网也不会通的
D局域网DNS服务器设置有误也是不对的，DNS域名解析，那么IP地址有可能是通的

#### 为了查看不断更新的日志文件，可以使用的指令是（D）

```
cat -n
vi
more
tail -f
```

linux 下 tail 用于看档案的结尾， -f参数 是follow的意思 当文件增长时,输出后续添加的数据

#### 使用什么命令把两个文件的合并成一个文件？A

```
cat
grep
awk
cut
```

1、cat 将两个文件拼接在一起，cat file1 file2 > file3

2、grep命令可以从一个或者多个文件中搜索特定的字符串模式，grep pattern files

3、awk的基本功能是在文件或字符串中基于指定规则浏览和抽取信息，awk '{if($4~/Brown/) print $0}' tab2

4、cut: 从数据文件或者命令的输出中截取（也就是剪出）各种各样的数据域，cut –cchars file

#### 下列提法中，不属于ifconfig命令作用范围的是 D

```
配置本地回环地址
配置网卡的IP地址
激活网络适配器
加载网卡到内核中
```

ifconfig

1.作用：ifconfig用于查看和更改网络接口的地址和参数，包括IP地址、网络掩码、广播地址，使用权限是超级用户。

2.格式    ifconfig -interface [options] address

3.主要参数如下：

-interface：指定的网络接口名，如eth0和eth1。

up：激活指定的网络接口卡。

down：关闭指定的网络接口。

broadcast address：设置接口的广播地址。

pointopoint：启用点对点方式。

address：设置指定接口设备的IP地址。

netmask address：设置接口的子网掩码。

#### 设umask为002, 则新建立的文件的权限是什么？A

```
-rw-rw-r--
rwxrwx-w-
-------w-
rwxrwxr-x
```

**文件默认权限是666**,“拿掉”002权限就是664,其中r-4,w-2,x-1。这里“拿掉”的概念不是数学上的减掉，如果没有这个权限位，也就不用“拿掉”了。

**文件夹的默认权限是777**，这样的话，结果是D。

#### Linux 有三个查看文件的命令，若希望在查看文件内容过程中可以用光标上下移动来查看文件内容，应使用命令。C

```
cat
more
less
menu
```

cat,less,more都可以查看，只是查看的方式不一样，less可以让光标上下移动，more只能用enter键往下翻，cat的话直接跳到最后一页了

#### Linux命令行下如何查找列出/usr/local这个目录下所有包含字符mrtg的文件?B

```
grep  "mrtg" /usr/local
grep -Rn "mrtg" /usr/local
find /usr/local -name 'mrtg'
find /usr/local -name 'mrtg' -R
```

find是根据name, ctime, mtime等信息搜索文件的命令，不会根据文件内容去检索，也就是它只利用了iNode的信息，所以CD不对。

说说A为啥不对吧，可以去瞧瞧，/usr/local下面几乎都是目录，所以grep需要加-R或-r表示递归查询子目录， -n是显示行号信息。另外，实际不加-n也可，毕竟没强调说，要输出'mrtg'所在行。即

```
`grep` `-r ``"mrtg"` `/usr/local`
```

就行了

#### 使用shell时，默认的环境变量放在哪里？A

```
~/.bash_profile
~/.bash
/etc/profile.d
~/bash
```

**/etc/profile**:此文件为系统的为每个用户设置环境信息,当用户第一次登录时,该文件被执行.

并从/etc/profile.d 目录的配置文件中搜集shell的设置.

/etc/bashrc :为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.

~/.bash_profile :每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.

~/.bashrc :该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取.

**~/.bash_logout** :当每次退出系统(退出bash shell)时,执行该文件. 

bash_profile 、.bashrc 、和.bash_logout

上面这三个文件是bash shell的用户环境配置文件，位于用户的主目录下。

**.bash_profile**是最重要的一个配置文件，它在用户每次登录系统时被读取，里面的所有 命令都会被bash执行。.profile(由Bourne Shell和Korn Shell使用)和.login(由C Shell使用)两个文件是.bash_profile的同义词，目的是为了兼容其它Shell。 **在Debian中使用.profile文件代 替.bash_profile文件。**

.bashrc 文件会在bash shell调用另一个bash shell时读取，也就是在shell中再键入bash命令启动一个新shell时就会去读该文件。这样可有效分离登录和子shell所需的环境。但一般 来说都会在.bash_profile里调用.bashrc脚本以便统一配置用户环境。

**.bash_logout** 在退出shell时被读取。所以我们可把一些清理工作的命令放到这文件中。

登录Linux时，首先启动 /etc/profile 文件，然后再启动用户目录下的 ~/.bash_profile、 ~/.bash_login或 ~/.profile文件中的其中一个(根据不同的linux操作系统的不同，命名不一样)，执行的顺序为：~/.bash_profile、 ~/.bash_login、 ~/.profile。

如果 ~/.bash_profile文件存在的话，一般还会执行 ~/.bashrc文件。

#### 下面说法哪个正确的：D

```
各个线程拥有相同的堆栈
i++是线程安全的，不需要同步
x=y是线程安全的，不需要同步
对进程来说，其虚拟内存的大小不受物理内存大小的限制
```

**D。**进程的虚拟内存大小并不受物理内存大小的限制，例32位处理器虚拟内存空间可能是4G，但物理内存实际是小于4G的，部分地址空间分配给了ROM、外设等。

A，各个线程有自己的堆和栈，并不相同。

B，i++操作不一定是原子性操作，CPU在执行时可能需要几条指令才能完成，包括读内存内容到寄存器，操作寄存器，从寄存器写回内存。

C，同B。

#### 网络服务的daemon是:A

```
netd
httpd
inetd
lpd
```

A:     Netd 就是Network Daemon 的缩写，表示Network守护进程. Netd负责跟一些涉及网络的配置，操作，管理，查询等相关的功能实现，比如，例如带宽控制（Bandwidth），流量统计，带宽控制，网络地址转换（NAT），个人局域网（pan），PPP链接，soft-ap，共享上网（Tether），配置路由表，interface配置管理，等等.好像Andorid用的

C：    inetd是监视一些网络请求的 [守护进程](http://baike.baidu.com/view/53123.htm) ，其根据网络请求来调用相应的服务进程来处理连接请求。它可以为多种服务管理连接，当 inetd 接到连接时，它能够确定连接所需的程序，启动相应的进程，并把 socket 交给它 。

####在CPU和物理内存之间进行地址转换时，（ B）将地址从虚拟（逻辑）地址空间映射到物理地址空间

```
TCB
MMU
CACHE
DMA
```

A.TCB,线程控制块；PCB，进程控制块

B.MMU(Memory Management Unit) 内存管理单元，是中央处理器用来管理虚拟内存和物理内存寄存器的控制线路，同时也负责虚拟内存映射为物理内存等。

C.CACHE,感觉在这道题里应该指的是高速缓冲存储器。

D.DMA，（direct memory access）直接内存存储，传输数据从一个地址空间到另一个地址空间。

#### 当前目录下有a和b两个文件，执行命令“ls>c”，请问文件c里面的内容是什么？ D

```
a
b
ab
abc
```

ls>c会**先生成c文件**,然后ls的结果就是abc,重定向到c中,所以c中是abc.

#### man 5 passwd  D

```
显示关于passwd的前五处说明文档显示关于passwd的前五处说明文档
显示passwd命令的使用方法
显示passwd命令的说明的前五行
显示passwd文件的结构
```

本题选D

man的级别： 
1：查看命令的帮助 
2：查看可被内核调用的函数的帮助 
3：查看函数和函数库的帮助 
4：查看特殊文件的帮助（主要是/dev目录下的文件） 
5：查看配置文件的帮助 
6：查看游戏的帮助 
7：查看其它杂项的帮助 
8：查看系统管理员可用命令的帮助 
man -f 【命令】–可以查看这个命令有哪些级别

man 5 passwd // 在入口为文件系统去查询passwd的帮助文档

#### 下面哪些是死锁的必要条件？A B C D

```
互斥
请求保持
不可剥夺
环路
```

产生死锁的四个必要条件： 
（1） 互斥条件：一个资源每次只能被一个进程使用。 
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 
（3） 不剥夺条件:进程已获得的资源，在使用完之前，不能强行剥夺。 
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

#### 统计日志中ip登陆次数,下面可以正确统计的为 CD

```bash
cat catalina.log  | awk -F ' ' '{print $3}' | sort | uniq -c | head -10
cat catalina.log | awk '{print $3}' | uniq -c | wc -l
cat catalina.log  | awk -F ' ' '{print $3}' | sort | uniq -c | wc -l
cat catalina.log | awk '{print $3}' | sort -k1nr | uniq -c | wc –l
```

**知识点：**

1、awk -F ' ' '{print $3}' 指定空格是分隔符进行分割，取第三个。（不指定**默认分隔符也是空格**）

2、uniq -c（uniq命令可以去除排序过的文件中的重复行，因此uniq经常和sort合用。也就是说，**为了使uniq起作用，所有的重复行必须是相邻的。**参数 - c ：进行计数）

3、wc -l 行计数。



A ： head -10 统计不完整。不符合题目意思

B ： 没排序。重复行不相邻。故uniq -c 无法起到正确的作用。故统计结果错误。

#### 在一台Linux服务器上通过rpm方式安装了dhcp软件包，下列关于dhcp服务器配置文件“dhcpd.conf”说法正确的是（CD ）多选

```
软件包安装好后，dhcpd.conf文件就位于“/etc/”目录下
dhcpd.conf文件默认情况下内容为空
dhcpd.conf文件缺省不存在，需要手工建立
dhcpd.conf文件的配置可以参考模板文件“dhcpd.conf.sample”进行
```

  **DHCP（Dynamic Host Configuration Protocol）动态主机设置协议**，是一个局域网的网络协议，使用UDP协议工作，主要有两个用途： 

  1、用于内部网或网络服务供应商自动分配IP地址； 

  2、给用户用于内部网管理员作为对所有计算机作中央管理的手段。

## 2019.6.26

#### 下面哪个命令可以从文本文件的每一行中截取指定内容的数据。D

```
cp
dd
fmt
cut
```

cut ：从文本文件的每一行中截取指定内容的数据。

cp ：用来复制文件或目录。

dd ：将指定的输入文件拷贝到输出文件中，在拷贝的过程中可以进行格式转换。

fmt ：将所有非空白行的长度设置为几乎相同，来进行简单的文本格式化。

#### 写出linux命令: 在当前目录及其子目录所有的.cpp文件中查找字符串"example", 不区分大小写？D

```bash
grep -i example ./*.cpp
grep -v example ./*.cpp
grep -i -v example ./*.cpp
grep -i -r example ./*.cpp
```

-i     ignore          忽略大小写

-r    recursion      递归(搜索子目录)

#### 下面有关文件系统元数据的描述，说法错误的是？D

```
元数据指用来描述一个文件的特征的系统数据，诸如访问权限、文件拥有者以及文件数据块的分布信息等等
我们可以使用stat命令来查看文件更多的元数据信息
Unix/Linux系统允许，多个文件名指向同一个inode号码
文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B，这是文件A就称为文件B的"硬链接"
```

硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。

若一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，**硬链接**就是同一个文件使用了多个别名。

若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是**软链接**。

#### 
缺省的Linux系统中，从后台启动进程，应在命令的结尾加上哪个符号？ （  B）

```
@
&
^
$
```

题目的意思应该是将程序放在**后台执行**,不占据 terminal中断,我差点理解成把程序从后台调回前台这个过程.那应该就是选择B了;

#### 在命令行下使用 vi 编辑一个文件时, 如何复制当前行？（最佳选项）C

```
cc
dd
yy
Ctrl + c
```

dd 删除光标所在的那一整行

yy 复制光标所在的那一整行

p 将已复制的数据在光标的下一行粘贴

P 将已复制的数据在光标的上一行粘贴

#### 下列关于 clone 和 fork 的区别描述正确的有？C

```
clone和fork最大不同在于fork不再复制父进程的栈空间，而是自己创建一个新的。
clone和fork最大不同在于clone不再复制父进程的栈空间，而是自己创建一个新的。
clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等
fork是clone的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等
```

fork() 函数复制时将父进程的所以资源都通过复制数据结构进行了复制，然后传递给子进程，所以 fork() 函数不带参数； clone() 函数则是将部分父进程的资源的数据结构进行复制，复制哪些资源是可选择的，这个可以通过参数设定，所以 clone() 函数带参数，没有复制的资源可以通过指针共享给子进程 

#### 下列关于文件系统中元数据（比如ext2中的inode）的基本作用及ext2和ext3的根本区别描述错误的有？B

```
EXT2 inode用来定义文件系统的结构以及描述系统中每个文件的管理信息，每个文件都有且只有一个inode，即使文件中没有数据，其索引结点也是存在的
EXT2 inode包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等信息。它是linux管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。
ext2文件系统是非日志文件系统，而ext3有多种日志模式
ext3文件系统能够极大地提高文件系统的完整性
```

EXT2 inode不包含文件的创建时间，ext3 inode包含。所以B错误。

Ext2 文件系统加上日志支持的下一个版本是 ext3     文件系统，它和 ext2 文件系统在硬盘布局上是一样的，其差别仅仅是 ext3 文件系统在硬盘上多出了一个特殊的     inode（可以理解为一个特殊文件），用来记录文件系统的日志，也即所谓的 journal。  

#### 现在将/目录下的www文件权限改为只有主用户有执行的权限的有AC

```bash
chmod 100 /www
chmod 001 /www
chmod u+x ,g-x,o-x /www
chmod o-x,g-x,u-x /www
```

语法格式： chmod  [模式] 文件
chmod    [八进制] 文件
操作对象：u   主用户   g 同组用户  o 其他用户  a(ugo) 所有用户
权限类别： r (4) 读  w(2) 写 x(1)执行  所有权限（7） 
 权限设定：+增加权限  - 取消权限  = 唯一设定权限
本题：主用户执行  对象 u 类别 x 

#### 下面哪些命令可以查看file1文件的第300-500行的内容？BC

```bash
cat file1 | tail -n +300 | head -n 200
cat file1| head -n 500 | tail -n +300
sed -n '300,500p' file1
```

```
head -n k          # 打印前k行
head -n -k         # 打印除最后k行外的所有内容
tail -n k          # 打印最后k行
tail -n +k         # 从k行开始打印
```

A选项：从第300行开始，接着输出前200行的内容，但这里的200行包括了第300行，不包括第500行。所以应该改为**cat file1 | tail -n +300 | head -n 201。**

B选项：先取出前500行，再从300行开始。 cat file1 | head -n 500 | tail -n + 300 ，正确。

C选项：sed命令 p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～

sed -n '300-500p' 打印300-500行，正确。

#### 文件exer1 的访问权限为rw-r--r-- ，现要增加所有用户的执行权限和同组用户的写权限，下列命令正确的是 AB

```bash
chmod a+x,g+w exer1
chmod 775 exer1
chmod o+x exer1
chmod g+w exer1
```

**所有用户**的执行权限

#### 以下关于读屏障、写屏障、通用屏障和优化屏障说法正确的是（ABC）

```
优化屏障则用于限制编译器的指令重排
通用屏障则对读写操作都有作用
读屏障用于保证读操作有序。屏障之前的读操作一定会先于屏障之后的读操作完成，写操作不受影响
写屏障可用于限制读、写操作顺序
```

内存屏障主要有：读屏障、写屏障、通用屏障、优化屏障、几种。
以**读屏障**为例，它用于保证读操作有序。屏障之前的读操作一定会先于屏障之后的读操作完成，写操作不受影响，同属于屏障的某一侧的读操作也不受影响。类似的，**写屏障**用于限制写操作。而**通****用屏障**则对读写操作都有作用。而**优化屏障**则用于限制编译器的指令重排，不区分读写。前三种屏障都隐含了优化屏障的功能。

#### 下面有关bash配置文件，说法正确的是？ ABD

```
.bash_logout：退出shell时，要执行的命令
.bash_profile：每个用户都可使用该文件输入专用于自己使用的shell信息，当用户登录时，该文件仅仅执行一次!默认情况下
/etc/bash.bashrc 该文件包含专用于个人的bash shell的bash信息，当登录时以及每次打开新的shell时，该文件被读取
/etc/profile：此文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行
```

.bash_profile 类似于编程中的构造函数，当登录shell时，shell会寻找该文件做环境初始化。
.bashrc 是在bash环境时.bash_profile的替补。
.bash_logout 类似于编程中的析构函数，当登录shell退出时，shell会寻找该文件，并按其指示办事。

/etc/profile是系统文件,对系统下全体用户起作用

C选项中：/etc/bash.bashrc 对所有用户起作用

而容易混淆的： ~/.bashrc 是对拥有当前home目录的用户起作用，也就是当前用户。

#### 以下属于网络操作系统的是？A B D E G

```
Unix
Linux
WIN98
WINDOWS NT
NETWARE 4.11
OS/2
LAN MANGER 4.0
```

[NOS](http://baike.baidu.com/view/238315.htm)与运行在[工作站](http://baike.baidu.com/view/7977.htm)上的[单用户操作系统](http://baike.baidu.com/view/2784915.htm)(如WINDOWS系列)或[多用户操作系统](http://baike.baidu.com/view/1157393.htm)（UNIX、Linux）由于提供的服务类型不同而有差别。一般情况下，NOS是以使[网络相关](http://baike.baidu.com/view/2905128.htm)特性达到最佳为目的的，如共享数据文件、[软件](http://baike.baidu.com/view/37.htm)应用，以及共享[硬盘](http://baike.baidu.com/view/4480.htm)、打印机、[调制解调器](http://baike.baidu.com/view/1074.htm)、扫描仪和传真机等。一般[计算机](http://baike.baidu.com/view/3314.htm)的[操作系统](http://baike.baidu.com/view/880.htm)，如DOS和OS/2等，其目的是让用户与系统及在此操作系统上运行的各种应用之间的交互作用最佳。

为防止一次由一个以上的用户对文件进行访问，一般网络[操作系统](http://baike.baidu.com/view/880.htm)都具有文件加锁功能。如果系统没有这种功能，用户将不会正常工作。文件加锁功能可跟踪使用中的每个文件，并确保一次只能一个用户对其进行编辑。文件也可由用户的口令加锁，以维持专用文件的专用性。

NOS还负责管理LAN用户和LAN打印机之间的连接。NOS总是跟踪每一个可供使用的打印机，以及每个用户的打印请求，并对如何满足这些请求进行管理，使每个端用户感到进行操作的打印机犹如与其[计算机](http://baike.baidu.com/view/3314.htm)直接相连。

由于[网络计算](http://baike.baidu.com/view/1090732.htm)的出现和发展，[现代操作系统](http://baike.baidu.com/view/2563933.htm)的主要特征之一就是具有上网功能，因此，除了在20世纪90年代初期，Novell公司的Netware等系统被称为网络操作系统之外，人们一般不再特指某个操作系统为网络操作系统。