[TOC]

## 2019.6.10

#### Linux下通过哪个命令怎么查看中断？B

```
cat /proc/ioports
cat /proc/interrupts
cat /proc/kcore
cat /proc/kms
```

/proc/interrupts 显示使用的中断

/proc/ioports 当前使用的I/O端口

/proc/kcore 系统物理内存映像。与物理内存大小完全一样，但不实际占用这么多的内存。

/proc/kmsg  内核输出的消息，也被送到syslog

**中断**是指在CPU正常运行期间，由于内外部事件或由程序预先安排的事件引起的CPU暂时停止正在运行的程序，转而为该内部或外部事件或预先安排的事件服务的程序中去，服务完毕后再返回去继续运行被暂时中断的程序。Linux中通常分为外部中断（又叫硬件中断）和内部中断（又叫异常）。

#### Linux文件权限一共10位长度，从前数第5-7位表示的内容是（A）
```
文件所有者所在组的权限
文件类型
文件所有者的权限
其他用户的权限
```

​        d                         rwx                                  rwx                                            rwx

​        ↑                           ↑                                       ↑                                                 ↑

是否为文件夹    所有者的权限          文件所有者组的权限                     其他用户的权限

#### Linux系统中某个可执行文件属于root并且有setid，当一个普通用户 mike运行这个程序时，产生的进程的有效用户和实际用户分别是？A

```
root mike
root root
mike root
mike mike
deamon mike
mike deamon
```

setuid位是让普通用户可以以root用户的角色运行只有root帐号才能运行的程序或命令。
因此当程序设置了setid权限位时，普通用户会临时变成root权限，但实际用户任然是原来的mike

#### Linux系统中，用户文件描述符0表示 _A 。

```
标准输入设备文件描述符
标准输出设备文件描述符
管道文件描述符
标准错误输出设备文件描述符
```

在Linux系统中,一切设备都看作文件。而每打开一个文件,就有一个代表该打开文件的文件描述符。程序启动时默认打开三个I/O设备文件:标准输入文件stdin,标准输出文件stdout,标准错误输出文件stderr,分别得到文件描述符0,1,2。

文件描述符0：标准输入文件stdin

文件描述符1：标准输出文件stdout

文件描述符2：标准错误输出文件stderr

#### 下面关于Android dvm的进程和Linux的进程,应用程序的进程说法正确的是 D

```
DVM指dalvik的虚拟机.每一个Android应用程序都在它自己的进程中运行，不一定拥有一个独立的Dalvik虚拟机实例.而每一个DVM都是在Linux中的一个进程，所以说可以认为是同一个概念.
DVM指dalvik的虚拟机.每一个Android应用程序都在它自己的进程中运行，不一定拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux 中的一个进程，所以说不是一个概念.
DVM指dalvik的虚拟机.每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的Dalvik虚拟机实例.而每一个DVM不一定都是在Linux 中的一个进程，所以说不是一个概念
DVM指dalvik的虚拟机.每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的 Dalvik虚拟机实例.而每一个DVM都是在Linux 中的一个进程，所以说可以认为是同一个概念.
```

一句话：每一个DVM都是在Linux 中的一个进程！

DVM指 dalivk 的虚拟机。每一个 Android 应用程序都在它自己的进程中运行，都拥有一个独立的 Dalvik 虚拟机实例。而每一个 DVM 都是在 Linux  中的一个进程，所以说可以认为是同一个概念。 

#### 在重新启动Linux系统的同时把内存中的信息写入硬盘，应使用（A）命令实现

```
#shutdown -r now
#halt
#reboot
#init3
```

在linux命令中reboot是重新启动，**shutdown -r now是立即停止然后重新启动，都说他们两个是一样的，其实是有一定的区别的**。

**shutdown**命令可以**安全地关闭**或重启Linux系统，它在系统关闭之前给系统上的所有登录用户提示一条警告信息。该命令还允许用户指定一个时间参数，可以是一个精确的时间，也可以是从现在开始的一个时间段。

精确时间的格式是hh:mm，表示小时和分钟，时间段由+ 和分钟数表示。系统执行该命令后会自动进行数据同步的工作。

该命令的一般格式: shutdown [选项] [时间] [警告信息]

命令中各选项的含义为:

\- k 并不真正关机而只是发出警告信息给所有用户

\- r 关机后立即重新启动

\- h 关机后不重新启动

\- f 快速关机重启动时跳过fsck

\- n 快速关机不经过init 程序

\- c 取消一个已经运行的shutdown  

**halt**是最简单的关机命令，其**实际上是调用shutdown -h命令**。

**reboot**的工作过程与halt类似，其作用是重新启动，而halt是关机。其参数也与halt类似。reboot命令重启动系统时是删除所有的进程，而不是平稳地终止它们。因此，**使用reboot命令可以快速地关闭系统，但如果还有其它用户在该系统上工作时，就会引起数据的丢失。所以使用reboot命令的场合主要是在单用户模式**。

**init**是所有进程的祖先，其进程号始终为1。init用于切换系统的运行级别，切换的工作是立即完成的。**init 0命令用于立即将系统运行级别切换为0，即关机；init 6命令用于将系统运行级别切换为6，即重新启动**

####  init启动进程需要读取()配置文件 D

```
/sbin/init
/bin/sh
/etc/sysvinit
/etc/inittab
```

/sbin/init在核心完整的加载后，开始运行系统的第一支程序，主要的功能就是准备软件运行的环境，包括系统的主机名称、网络配置、语系处理、文件系统格式及其他服务的启动等。 

/bin/sh解释脚本的shell命令，开机后运行

/etc/sysvinit就是 system V 风格的 init 系统，顾名思义，它源于 System V 系列 UNIX。sysvinit 中运行模式描述了系统各种预订的运行模式。(初始化用)

/etc/inittab定义了系统引导时的运行级别, 进入或者切换到一个运行级别时做什么。

####  一个文件名字为rr.Z，可以用来解压缩的命令是：D

```
tar
gzip
compress
uncompress
```

tar是操作.tar的命令
gzip是压缩.gz压缩包的命令
compress：压缩.Z文件
uncompress：解压缩.Z文件

#### 目录在linux文件系统中是以怎样的形式存在的？B

```
文件夹
文件
inode
软链接
```

一切皆文件

####  有一个文件ip.txt，每行一条ip记录，共若干行，下面哪个命令可以实现“统计出现次数最多的前3个ip及其次数”？（B）
```
uniq -c ip.txt│sort -nr│head -n 3
sort ip.txt│uniq -c│sort -rn│head -n 3
cat ip.txt │count -n│sort -rn│head -n 3
cat ip.txt │sort │uniq -c│sort -rn│top -n 3
```

sort 是按ASCII码排序

-n   依照数值的大小排序。

-r   以相反的顺序来排序。

uniq -c 是去重并显示个数

head -n 3 为取前3行

####  Linux中，一个端口能够接受tcp链接数量的理论上限是？D

```
1024
65535
65535 * 65535
无上限
```

标识一个TCP连接的是，客户端和服务器的IP地址加端口号，尽管服务器IP地址和端口号一样，但是客户端IP地址是不一样的，而客户端端口号只有本地意义，所以理论上服务器一个端口号能接受的TCP连接是无上限的。

####  UNIX系统中进程由三部分组成：进程控制块，正文段和数据段。这意味着一个程序的正文与数据可以是分开的，这种分开的目的是为了？A B C

```
可共享正文
可共享数据
可重入
方便编程
以上全部
```

通常，一个进程由三个部分组成：进程控制块PCB、数据和程序。在UNIX中，一个进程也由三个部分组成：进程控制块、数据段和共享正文段，并有其自身的不同含义。
进程运行时用到的数据以及工作区，构成了一个进程的数据段。要注意的是，如果进程执行的程序是不能被共享的，那么也把它归入到数据段中。
为了管理好进程的共享正文段，UNIX在内存专门开辟了一个text结构区域，形成正文段表text[ ].
因此，划分进程为进程控制块、正文段、数据段可以实现共享正文，共享数据和可重入。

#### Redhat 9所支持的安装方式有?A C D 

```
通过HTTP进行网络安装
通过Telnet进行网络安装
通过NFS进行网络安装
从本地硬盘驱动器进行安装
```

光盘安装 (常规情况) 硬盘安装 (无光驱情况)
网络安装-NFS方式 (适合于批量安装大量服务器，和kickstart自动安装一起使用)
网络安装-FTP方式 (适合于批量安装大量服务器，和kickstart自动安装一起使
网络安装-HTTP方式 (适合于批量安装大量服务器，和kickstart自动安装一起使

#### 关于静态库与动态库的区别，以下说法错误的是（A）

```
加载动态库的程序运行速度相对较快
静态库会被添加为程序的一部分进行使用
动态库可用节省内存和磁盘空间
静态库重新编译，需要将应用程序重新编译
```

**1静态链接库的优点** 

 (1)代码装载速度快，执行速度略比动态链接库快； 

 (2)只需保证在开发者的计算机中有正确的.LIB文件，在以二进制形式发布程序时不需考虑在用户的计算机上.LIB文件是否存在及版本问题，可避免DLL地狱等问题。 

**2动态链接库的优点** 

 (1)更加节省内存并减少页面交换；

 (2) DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；

 (3)不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；

 (4)适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试。

**3不足之处**

 (1)使用静态链接生成的可执行文件体积较大，包含相同的公共代码，造成浪费；

 (2)使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息。而使用运行时动态链接，系统不会终止，但由于DLL中的导出函数不可用，程序会加载失败；速度比静态链接慢。当某个模块更新后，如果新模块与旧的模块不兼容，那么那些需要该模块才能运行的软件，统统撕掉。这在早期Windows中很常见。

**动态库的函数到实际使用的时候才加载到内存，所以运行速度较慢**

#### linux下查看当前网络连接的命令。B

```
ping
netstat
route
tracert
```

ping 命令不用说大家都知道，不论windows还是linux，对于PING命令无非是在测试网络连接的性能情况
netstat，字面理解网络状态，包括网络地址信息，网络的连接状态，网络的子网掩码等等，通过命令 netstat -ie ，效果和ifconfig一样
route是路由表信息命令主要是查看路由表相关的
tracert表示并不是很准确，在linux下应该是traceroute，字面理解路径追踪，其实就是在网络中包通过的路由器等相关的个数信息。

#### 使用pthread库的多线程程序编译时需要加什么连接参数? A

```bash
-lpthread
-fthis-is-varialble
-fcond-mismatch
-MMD
```

  由于pthread库不是[Linux](http://lib.csdn.net/base/linux)系统默认的库，连接时需要使用库libpthread.a,所以在使用pthread_create创建线程时，在编译中要加-lpthread参数:
gcc -o pthread -lpthread pthread.c

-fthis-is-varialble 就是向传统c++看齐，可以使用this当一般变量使用.

-fcond-mismatch允许 [条件表达式](http://baike.baidu.com/view/3523810.htm) 的第二和第三参数 [类型不匹配](http://baike.baidu.com/view/672303.htm) ，表达式的值将为void类型

-MMD和-MM相同，但是输出将导入到.d的文件里面

#### 写出完成以下功能的Linux命令:使用sed命令, 将文件xyz中的单词AAA全部替换为BBB (B)

```
sed 's/AAA/BBB' xyz
sed 's/AAA/BBB/g' xyz
sed 's/AAA/BBB/p' xyz
sed 's/AAA/BBB/d' xyz
```

s表示替换命令， /AAA 表示匹配AAA， /BBB 表示把匹配替换成BBB，/g 表示一行上的替换所有的匹配） xyz 表示替换xyz文件中的xyz

 g 表示行内全面替换。 

p 表示打印行。 

w 表示把行写入一个文件。

x 表示互换模板块中的文本和缓冲区中的文本。

y 表示把一个字符翻译为另外的字符（但是不用于正则表达式）

\1 子串匹配标记 

& 已匹配字符串标记   

#### 采用多路复用I/O监听3个套接字的数据时，如果套接字描述符分别是：5,17,19,则

```bash
`select(``int` `maxfd,``struct` `fd_set* rdset,NULL,NULL)`
```

中的maxfd应取为（B)

```
4
20
5
9
```

Maxfd要监视的文件描述符的范围，一般取监视的描述符数的最大值+1

#### 在unix系统下执行chmod(“/usr/test/sample”,0753)之后该文件sample的访问权限为 C

```
拥有者可读写执行，同组用户可写可执行，其他用户可读可执行
拥有者可读写执行，同组用户可读写，其他用户可读可执行
拥有者可读写执行，同组用户可读可执行，其他用户可写可执行
拥有者可读写执行，同组用户可读可执行，其他用户可读写
```

r：读取权限，数字代号为"4"。 

w：写入权限，数字代号为"2"。 

x：执行或切换权限，数字代号为"1"。 

7：421  5:41 3:12 分别为三种不同用户对文件所执行的操作，7代表对文件拥有者所能执行的操作，为4+2+1的组合， 代表可读客写可执行；5代表同组用户客执行的操作，只能为4+1的组合，代表可读可执行；3为其他用户所能执行的操作，为2+1的组合，代表可写可执行。

#### 下面说法哪个正确的：D

```
各个线程拥有相同的堆栈
i++是线程安全的，不需要同步
x=y是线程安全的，不需要同步
对进程来说，其虚拟内存的大小不受物理内存大小的限制
```

**D。**进程的虚拟内存大小并不受物理内存大小的限制，例32位处理器虚拟内存空间可能是4G，但物理内存实际是小于4G的，部分地址空间分配给了ROM、外设等。

A，各个线程有自己的堆和栈，并不相同。

B，i++操作不一定是原子性操作，CPU在执行时可能需要几条指令才能完成，包括读内存内容到寄存器，操作寄存器，从寄存器写回内存。

C，同B。

#### 关于 Linux 系统上同一个程序的多个进程实例共享一个 TCP 监听端口的说法, 哪个不正确?D

```
每个进程都使用 SO_REUSEPORT 选项,然后绑定同一个地址和端口
每个进程分别绑定不同的网卡地址的同一端口
第一个进程先绑定到监听地址端口, 然后 fork 子进程共享使用
每个进程分别绑定一次, 但只有最后一个调用的进程才能收到数据
```

D是竞争调度的结果，而不是最后调用的进程收到数据。

A使用SO_REUSEPORT，绑定统一地址和端口。

B分别绑定 不同的网卡地址的同一端口，TCP的四元组并不冲突。

C使用fork创建子进程共享，也没有问题。

#### 下面关于i节点描述错误的是A

```
i节点和文件是一一对应的
i节点能描述文件占用的块数
i节点描述了文件大小和指向数据块的指针
通过i节点实现文件的逻辑结构和物理结构的转换
```

在做这道题之前首先要明白i节点是什么东西！

linux中，文件查找不是通过文件名称来查找的。实际上是通过i节点来实现文件的查找定位的。我们可以形象的将i节点看做是一个指针fip.

这个节点和文件不是一一对应的，通过ln可以建立其他的节点。

节点与文件是一对多。在硬链接下，多个文件名共用一个iNode

#### 在CPU和物理内存之间进行地址转换时，（B ）将地址从虚拟（逻辑）地址空间映射到物理地址空间

```
TCB
MMU
CACHE
DMA
```

A.TCB,线程控制块；PCB，进程控制块

B.MMU(Memory Management Unit) 内存管理单元，是中央处理器用来管理虚拟内存和物理内存寄存器的控制线路，同时也负责虚拟内存映射为物理内存等。

C.CACHE,感觉在这道题里应该指的是高速缓冲存储器。

D.DMA，（direct memory access）直接内存存储，传输数据从一个地址空间到另一个地址空间。

#### 在RHEL5系统中，下面关于shell环境变量配置文件的描述，正确的是（ A ）

```
用户登录系统时，bash首先执行/etc/profile配置文件和/etc/profile.d/目录下的配置文件，这些配置文件对所有用户都有效
用户登录系统时，bash首先执行.bash_profile文件和.bashrc文件，这些配置文件对所有用户都有效
用户主目录下的.bashrc设置为每次登录时执行，而.bash_profile则为每次打开新的终端时执行
执行用户主目录下的环境变量配置文件时，不可以重复设置用户登录时配置文件中已经设置的选项
```

- /ect/profile
  - 此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从 **/etc/profile.d** 目录的配置文件中搜集shell的设置.
- /etc/bashrc
  - 为每一个 **运行bash shell** 的用户执行此文件.当bash shell被打开时,该文件被读取.
- ~/.bash_profile
  - 每个用户都可使用该文件输入 **专用于** 自己使用的shell信息, **当用户登录时,该文件仅仅执行一次** !默认情况下,他设置一些环境变量,执行~/.bashrc文件.
- ~/.bashrc
  - 该文件包含专用于用户的bash shell的bash信息 **,当登录时以及每次打开新的shell时,该该文件被读取** .
- ~/.bash_logout
  - 当每次退出系统(退出bash shell)时,执行该文件.

#### 程序员小李通过管道统计prog.c函数中for语句通过的次数，需要使用的指令分别是BC

```
vi
grep
wc
sort
```

#### 将光盘/dev/hdc卸载的命令是?AC

```
umount /mnt/cdrom /dev/hdc
mount /dev/hdc
umount /dev/hdc
mount /mnt/cdrom /dev/hdc
```

挂载设备使用mount，卸载设备使用umount，有三种方式，通过设备名，挂载点或者设备名和挂载点

如题目所示：

umount /dev/hdc

umount /mnt/cdrom

umount /mnt/cdrom /dev/hdc